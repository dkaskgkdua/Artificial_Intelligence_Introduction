# Uninformed Search 

## 비정보 탐색(Uninformed Search) 개요
비정보 탐색(Uninformed Blind Search)은 "문제에 대한 추가적인 정보(예: 목표까지의 거리) 없이 탐색 공간을 탐색하는 알고리즘 집합"입니다.
이는 "목표 상태에 대한 사전 지식이나 휴리스틱 정보 없이 탐색 공간을 탐색하는 알고리즘"으로, "오직 문제 정의에 기반한 일반적인 규칙을 사용하여 상태를 확장하고 목표를 찾습니다."
반면, 정보 탐색(Informed Heuristic Search)은 휴리스틱을 사용하여 탐색을 안내합니다.
모든 탐색 알고리즘은 탐색 **트리(Search Tree)**의 개념을 기반으로 합니다.
탐색 트리는 "상태 공간 탐색의 특정 방식을 나타내는 트리 구조"이며, 노드는 상태를, 간선은 유효한 전이(legal transitions)를 나타냅니다. 탐색 과정은 "이미 탐색된 상태의 후속 노드를 생성(expanding states)"하여 상태 공간을 탐색하며, "모든 상태는 목표 상태인지 평가"됩니다.

탐색 전략은 노드 확장 순서에 따라 정의되며, 다음 네 가지 차원으로 평가됩니다:
- 완료성(Completeness): "솔루션이 존재할 경우 알고리즘이 항상 솔루션을 찾아낼 수 있는 능력."
- 시간 복잡도(Time Complexity): "알고리즘이 솔루션을 찾기 위해 생성하는 노드의 수로 측정되는 효율성."
- 공간 복잡도(Space Complexity): "알고리즘이 솔루션을 찾기 위해 메모리에 저장해야 하는 노드의 최대 수로 측정되는 효율성."
- 최적성(Optimality): "알고리즘이 항상 가장 비용이 적거나 가장 좋은 솔루션을 찾아낼 수 있는 능력."

시간 및 공간 복잡도는 다음 용어를 기반으로 측정됩니다:
- b: 탐색 트리의 최대 분기 계수(maximum branching factor).
- d: 가장 비용이 적은 솔루션의 깊이(depth of the least-cost solution).
- m: 상태 공간의 최대 깊이(maximum depth of the state space, 무한대일 수 있음).

--------------------------------------------------------------------------------

## 주요 비정보 탐색 알고리즘
### 너비 우선 탐색(Breadth-First Search, BFS)
- 기본 아이디어: "가장 얕은 미확장 노드를 확장"합니다.
- 프린지(Fringe) 구현: "FIFO(선입선출) 큐로 구현됩니다. 새로 생성된 후속 노드는 큐의 끝에 추가되어 가장 얕은, 즉 가장 먼저 추가된 노드가 먼저 확장되도록 합니다."
- 반복 상태 처리: 이미 확장된 노드는 큐에 추가하지 않거나 확장하지 않는 간단한 전략을 사용합니다.
- 속성:
   - 완료성: "예. 솔루션이 존재하면 항상 솔루션을 찾습니다."
   - 최적성: "예. 단계 비용이 동일하거나 비감소하는 경우 최적성도 보장하여 가장 비용이 적거나 가장 얕은 깊이의 솔루션을 찾습니다."
   - 시간 복잡도: O(b^d) * 최악의 경우, 깊이 d에 하나의 목표 노드가 있을 때, BFS는 모든 깊이 d까지의 노드를 생성하고 깊이 d+1의 일부 노드를 생성합니다. 이는 b + b^2 + ... + b^d + (b^(d+1) - b) 노드와 같아 O(b^d)가 됩니다.
   - 공간 복잡도: O(b^d) * 최악의 경우, 깊이 d에는 b^(d+1)개의 미확장 노드가 큐에 있을 수 있으므로 공간 복잡도는 O(b^d)입니다.
   - 주요 실용적 단점: "기하급수적인 공간 복잡도(exponential space complexity)"입니다. 예를 들어, 분기 계수(b)=10일 때, 깊이 8의 솔루션을 찾으려면 약 1TB의 메모리가 필요할 수 있습니다.

### 깊이 우선 탐색(Depth-First Search, DFS)
- 기본 아이디어: "가장 깊은 미확장 노드를 확장"합니다.
- 프린지(Fringe) 구현: "LIFO(후입선출) 스택으로 구현됩니다. 새로 생성된 후속 노드는 스택의 시작 부분에 추가되어 가장 깊은, 즉 가장 최근에 추가된 노드가 먼저 확장되도록 합니다."
- 반복 상태 처리: 이미 확장된 노드는 스택에 추가하지 않거나 확장하지 않는 간단한 전략을 사용합니다.
- 속성:
   - 완료성: "트리가 무한한 깊이를 가지면 완료성이 없습니다." 즉, 무한한 깊이의 경로가 있는 경우 솔루션을 찾지 못할 수 있습니다.
   - 최적성: "아니오." 먼저 발견되는 솔루션이 항상 가장 비용이 적거나 가장 얕은 깊이의 솔루션은 아닙니다.
   - 시간 복잡도: "지수적(Exponential)". 최악의 경우 "O(b^m)"입니다. 이는 DFS가 목표를 찾기 위해 "해 공간의 최대 깊이(m)까지 거의 모든 경로를 따라 내려가야 할 수 있음"을 의미합니다.
   - 공간 복잡도: "선형(Linear)". O(bm) * 최악의 경우, 깊이 m에서 b개의 노드와 이전 깊이에서 (m-1)*(b-1)개의 노드를 저장할 수 있어 총 O(bm)입니다.
   - 주요 장점: "메모리 효율적입니다. DFS는 선형 공간" 복잡도를 가집니다.

### 반복 심화 탐색(Iterative Deepening Search, IDS)
- 기본 아이디어: "깊이 제한이 점진적으로 증가하는 여러 번의 DFS를 실행"합니다.
- L=0에서 시작하여, 솔루션이 발견되지 않으면 깊이 제한 L을 증가시키면서 초기 상태 S0에서 DFS를 실행합니다.
- 속성:
   - 완료성: "예."
   - 최적성: "예, 경로 비용이 비감소 함수인 한."
   - 공간 복잡도: "O(b^d)" (깊이 우선 탐색이 여러 번 실행되기 때문에 최대 깊이 제한 d에서의 DFS와 유사). "DFS의 작은 메모리 사용량 특성"을 가집니다.
   - 시간 복잡도: "O(b^d)" (BFS 또는 제한된 깊이의 DFS와 점근적으로 동일). * IDS는 여러 번의 탐색을 반복하지만, "대부분의 시간은 목표 깊이에 가까운 노드를 확장하는 데 소비"됩니다. 따라서 "BFS와 비교했을 때, 깊은 솔루션의 경우 총 노드 생성 수의 차이는 상대적으로 작습니다." 예를 들어, b=10, d=5일 때, IDS는 BFS보다 약 11% 더 많은 노드를 생성합니다.
   - 장점: "IDS는 DFS의 작은 메모리 footprint와 BFS의 완료성 보장을 결합"합니다.
   - 실용적 측면: "실제로 IDS는 큰 탐색 공간과 알 수 없는 솔루션 깊이에서 선호되는 균일 탐색 방법입니다."
### 균일 비용 탐색(Uniform Cost Search, UCS)
   - 기본 아이디어: "시작 상태 S에서 노드 n까지의 비용 g(n)이 가장 적은 노드를 항상 확장"합니다.
   - 목적: "최저 비용 솔루션을 찾는 것"입니다. BFS가 최단 경로(가장 적은 수의 단계)를 찾는 반면, "UCS는 각 단계에 할당된 실제 비용을 고려하여 전체 비용이 가장 낮은 경로를 우선적으로 탐색"합니다.
   - 프린지 구현: 우선순위 큐(priority queue)를 사용하여 g(n) 값이 가장 작은 노드를 우선적으로 확장합니다.
   - 속성:
     - 완료성: "예." 모든 단계 비용이 ε > 0보다 크고 유한한 분기 계수를 가정할 때, 목표 상태의 경로 비용과 같아지기까지 유한한 노드 확장 수가 필요하므로 유한한 단계 내에 도달합니다.
     - 최적성: "예." UCS가 최적이 아니라면, 발견된 목표 상태보다 더 작은 경로 비용을 가진 목표 상태가 존재해야 하지만, UCS의 정의상 더 작은 비용을 가진 노드를 먼저 확장했을 것이므로 모순됩니다.
     - 복잡도: 최악의 경우 시간 및 공간 복잡도는 O(b^(1 + floor(C*/ε)))입니다. 여기서 C*는 최적 솔루션의 비용이고 ε는 각 단계의 최소 비용입니다. 이는 모든 비용이 거의 같을 때 솔루션의 깊이와 유사합니다.
     - BFS와의 유사성: "비용이 동일(또는 거의 동일)할 경우 BFS와 유사하게 동작"합니다.

--------------------------------------------------------------------------------

## 비정보 탐색 알고리즘 비교 및 선택 기준


| 특성         |BFS|DFS|IDS|UCS|
|------------|-|-|-|-|
| **완료성**    |예|아니오 (무한 깊이)|예|예|
| **최적성**    |예 (얕은 솔루션)|아니오|예 (얕은 솔루션)|예 (최저 비용)|
| **시간 복잡도** |O(b^d)|O(b^m) (지수적)|O(b^d)|O(b^(C*/ε))|
| **공간 복잡도** |O(b^d) (지수적)|O(bm) (선형)|O(bd) (선형)|O(b^(C*/ε))|
| **프린지 구현** |FIFO 큐|LIFO 스택|DFS 기반 (LIFO)|우선순위 큐|

알고리즘 선택 기준:
- 목표가 깊지 않을 때, 무한한 경로, 많은 루프, 또는 작은 탐색 공간: BFS가 더 선호됩니다. 또한, "최단 경로를 보장해야 할 때도 더 나은 선택입니다."
- 많은 목표, 루프가 적고 무한한 경로가 없을 때: DFS가 더 나을 수 있습니다. 특히, "DFS는 메모리 측면에서 훨씬 좋습니다."
- 큰 탐색 공간과 알 수 없는 솔루션 깊이: IDS가 "실제로 선호되는 균일 탐색 방법"입니다. 이는 DFS의 메모리 효율성과 BFS의 완료성 및 최적성을 결합하기 때문입니다.
- 각 단계의 비용이 다르며 최저 비용 솔루션이 필요할 때: UCS가 가장 적합합니다.

--------------------------------------------------------------------------------
## 핵심 용어 정의
- 비정보 탐색 (Uninformed Blind Search): 목표 상태에 대한 추가 정보 없이 탐색 공간을 탐색하는 알고리즘.
- 정보 탐색 (Informed Heuristic Search): 휴리스틱 정보를 사용하여 탐색 과정을 안내하는 알고리즘.
- 탐색 트리 (Search Tree): 상태 공간 탐색의 특정 방식을 나타내는 트리 구조.
- 상태 공간 (State Space): 문제의 모든 가능한 상태와 이들 간의 전이(transitions)를 나타내는 그래프.
- 노드 확장 (Expanding States): 현재 노드의 후속 노드들을 생성하는 과정.
- 목표 상태 (Goal State): 탐색 알고리즘이 도달하고자 하는 최종 상태.
- 프린지 (Fringe) / OPEN 리스트: 아직 확장되지 않았지만 발견된 노드들의 집합.
- 완료성 (Completeness): 솔루션이 존재할 경우 알고리즘이 항상 솔루션을 찾아낼 수 있는 능력.
- 최적성 (Optimality): 알고리즘이 항상 가장 비용이 적거나 가장 좋은 솔루션을 찾아낼 수 있는 능력.
- 시간 복잡도 (Time Complexity): 솔루션을 찾기 위해 생성하는 노드의 수로 측정되는 효율성.
- 공간 복잡도 (Space Complexity): 메모리에 저장해야 하는 노드의 최대 수로 측정되는 효율성.
- 분기 계수 (Branching Factor, b): 탐색 트리에서 하나의 노드가 가질 수 있는 최대 자식 노드의 수.
- 솔루션 깊이 (Depth of the Least-Cost Solution, d): 시작 노드로부터 가장 비용이 적은 솔루션까지의 깊이.
- 최대 깊이 (Maximum Depth of the State Space, m): 상태 공간 트리의 최대 깊이.
- 너비 우선 탐색 (Breadth-First Search, BFS): 가장 얕은 미확장 노드를 먼저 확장하는 알고리즘 (FIFO 큐).
- 깊이 우선 탐색 (Depth-First Search, DFS): 가장 깊은 미확장 노드를 먼저 확장하는 알고리즘 (LIFO 스택).
- 반복 심화 탐색 (Iterative Deepening Search, IDS): 깊이 제한이 점진적으로 증가하는 여러 번의 DFS를 실행하는 알고리즘.
- 균일 비용 탐색 (Uniform Cost Search, UCS): 시작 상태로부터 현재 노드까지의 경로 비용이 가장 적은 노드를 먼저 확장하는 알고리즘.
- 재방문 상태 (Repeated States): 이전에 방문하거나 확장했던 상태를 다시 만나는 경우.
- FIFO (First-In, First-Out): 큐에서 사용되는 방식.
- LIFO (Last-In, First-Out): 스택에서 사용되는 방식.